#include <iostream>

using namespace std;

class Data{
public:
    Data(int dato1, int dato2): dato1{dato1}, dato2{dato2}{
        
    }
        
    
    int getDato1() const;
    void setDato1(int value);
    
    int getDato2() const;
    void setDato2(int value);
    
private:
    int dato1, dato2;
};


class Node{
public:
    Node(): next{nullptr}{
        data = Data;
    }
    Node(int dato1, int dato2){
        data= Data{dato1,dato2};
    }
    
                    
    void push_back(Data d){
        if(next) next ->push_back(d);
     else next = new Node(d);   
    }
    
    Data pop_back(){
        if(next){
           if(next->getNext() == nullptr){               
               return next->getData();
               delete next;
               next = nullptr;
               
        
    }else return next ->pop_back();
        }else{
            throw string {"Error lista vacia"};
        }}
    
        
    Data & getData();
    void setData(const Data &value);
    Node *getNext() const;
    void setNext(Node *value);
    
private:
    Data data;
    Node * next;
};

void push_front(Node * first, Data d){ //aÃ±ade uno a la lista 
    Node * aux = new Node(d);
    aux->setNext(first->getNext());
    first->setData(aux); // Para nuevo enlace y ponerlo como primero
}
Data pop_front(Node * first){  // elimina el primero y lo saca de la lista
    Data result = first->getNext()->getData();
    Node * aux = first->getNext();
    first->setNext(aux->getNext());
    delete aux;
               
}

Node * filter_greater_than(Node* first, Data const & d){
    Node * it = nullptr;
    for(it = first->getNext(); it != nullptr; it->setNext(it->getNext())){
        if(it->getData().getDato1() > d.getDato1()){
            result->push_back(new Node(it));
        }
        
    }
            return result;
} // devuelve los valores mas grandes que el q se le pasen



int main()
{   
    Node * lista = new Node();
    lista->push_back(Data(2,3));
    lista->push_back(Data(3,7));
    
    Data aux = lista->pop_back(); // se elimina el 3,7 y los datos se almacenan en el aux
    
    push_front(lista, Data(1,2)); // se mete 1,2 delante de 2,3
    push_front(lista, Data(3,2)); // se mete 3,2 delante de 1,2
    
    Data aux2 = pop_front(lista); // elimina 3,2 y los datos se almacenan en el aux2
    
    cout << aux2.getDato1() << endl ; // ejemplo
     
    cout << "             " << endl;
    return 0;
}




int Data::getDato1() const
{
return dato1;
}

void Data::setDato1(int value)
{
dato1 = value;
}

int Data::getDato2() const
{
return dato2;
}

void Data::setDato2(int value)
{
dato2 = value;
}

Data Node::getData() const
{
return data;
}

void Node::setData(const Data &value)
{
data = value;
}

Node *Node::getNext() const
{
return next;
}

void Node::setNext(Node *value)
{
next = value;
}
/*   Node(const Data & value): dato{value}{      //formas de poner los constructores 

}

     Node(Node *n){
    data = Data(n->getData());
         }

                 Data & getData();
        void setData(const Data &value);    */



//formas de poner el nodo
/* Data d(3,4);
 Node * n2 = new Node(d);
 Node * n3 = new Node(n2);
 */
